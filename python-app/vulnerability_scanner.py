import requests
import ssl
import socket
from urllib.parse import urlparse
import re
import nmap
import os
import time
import hashlib
import dns.resolver

class VulnerabilityScanner:
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'SECURE-CITY-IQ-Scanner/1.0'
        })
        self.virustotal_api_key = os.getenv('VIRUSTOTAL_API_KEY')

    def scan_url(self, url):
        """
        Perform comprehensive vulnerability scan on a URL
        """
        results = {
            'url': url,
            'vulnerabilities': [],
            'security_headers': {},
            'ssl_info': {},
            'open_ports': [],
            'severity': 'LOW',
            'dns_info': {}
        }

        try:
            # Parse URL
            parsed = urlparse(url)
            if not parsed.scheme:
                url = 'https://' + url
                parsed = urlparse(url)

            domain = parsed.netloc
            port = parsed.port or (443 if parsed.scheme == 'https' else 80)

            # Perform DNS lookup to verify domain exists and is reachable
            dns_info = self.perform_dns_lookup(domain)
            results['dns_info'] = dns_info

            if not dns_info.get('resolved', False):
                results['vulnerabilities'].append(f"DNS RESOLUTION FAILED: {dns_info.get('error', 'Domain not found')}")
                results['severity'] = 'HIGH'
                return results

            # Check SSL if HTTPS
            if parsed.scheme == 'https':
                ssl_info = self.check_ssl_certificate(domain, port)
                results['ssl_info'] = ssl_info
                if ssl_info.get('issues'):
                    results['vulnerabilities'].extend(ssl_info['issues'])
                    results['severity'] = 'HIGH'

            # Check security headers
            headers_info = self.check_security_headers(url)
            results['security_headers'] = headers_info
            if headers_info.get('missing_critical'):
                results['vulnerabilities'].extend(headers_info['missing_critical'])
                if results['severity'] == 'LOW':
                    results['severity'] = 'MEDIUM'

            # Check for common vulnerabilities
            vuln_checks = self.perform_vulnerability_checks(url)
            results['vulnerabilities'].extend(vuln_checks)
            if any('CRITICAL' in str(v) or 'HIGH' in str(v) for v in vuln_checks):
                results['severity'] = 'HIGH'

            # Check open ports (basic check)
            ports_info = self.check_common_ports(domain)
            results['open_ports'] = ports_info

        except Exception as e:
            results['vulnerabilities'].append(f"Scan error: {str(e)}")
            results['severity'] = 'UNKNOWN'

        return results

    def check_ssl_certificate(self, domain, port=443):
        """
        Check SSL certificate validity and issues
        """
        info = {'valid': False, 'issuer': '', 'expiry': '', 'issues': []}

        try:
            context = ssl.create_default_context()
            with socket.create_connection((domain, port), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=domain) as ssock:
                    cert = ssock.getpeercert()
                    info['valid'] = True
                    info['issuer'] = dict(cert.get('issuer', []))
                    info['expiry'] = cert.get('notAfter', '')

                    # Check for common SSL issues
                    if 'subjectAltName' not in cert:
                        info['issues'].append("Missing Subject Alternative Name (SAN)")

        except ssl.SSLError as e:
            info['issues'].append(f"SSL Error: {str(e)}")
        except Exception as e:
            info['issues'].append(f"SSL Check Failed: {str(e)}")

        return info

    def check_security_headers(self, url):
        """
        Check for important security headers
        """
        headers = {}
        missing_critical = []

        try:
            response = self.session.get(url, timeout=10, allow_redirects=True)
            response_headers = response.headers

            # Critical security headers
            critical_headers = {
                'X-Frame-Options': 'Prevents clickjacking',
                'X-Content-Type-Options': 'Prevents MIME sniffing',
                'X-XSS-Protection': 'Basic XSS protection',
                'Strict-Transport-Security': 'Enforces HTTPS',
                'Content-Security-Policy': 'Prevents XSS and injection attacks'
            }

            for header, description in critical_headers.items():
                if header in response_headers:
                    headers[header] = response_headers[header]
                else:
                    missing_critical.append(f"Missing {header}: {description}")

            # Check for server info disclosure
            if 'Server' in response_headers:
                headers['Server'] = response_headers['Server']
                if 'apache' in response_headers['Server'].lower() or 'nginx' in response_headers['Server'].lower():
                    missing_critical.append("Server version disclosed - consider hiding server info")

        except Exception as e:
            missing_critical.append(f"Header check failed: {str(e)}")

        return {'headers': headers, 'missing_critical': missing_critical}

    def perform_vulnerability_checks(self, url):
        """
        Perform basic vulnerability checks
        """
        vulnerabilities = []

        try:
            # Test for basic SQL injection
            sql_payloads = ["'", "''", "' OR '1'='1", "' OR 1=1 --"]
            for payload in sql_payloads:
                test_url = url + payload
                try:
                    response = self.session.get(test_url, timeout=5)
                    if 'sql' in response.text.lower() or 'mysql' in response.text.lower() or 'syntax' in response.text.lower():
                        vulnerabilities.append(f"POTENTIAL SQL INJECTION: {test_url}")
                        break
                except:
                    pass

            # Test for XSS
            xss_payloads = ['<script>alert("XSS")</script>', '<img src=x onerror=alert("XSS")>']
            for payload in xss_payloads:
                test_url = url + '?test=' + payload
                try:
                    response = self.session.get(test_url, timeout=5)
                    if payload in response.text:
                        vulnerabilities.append(f"POTENTIAL XSS: {test_url}")
                        break
                except:
                    pass

            # Check for directory listing
            dirs_to_check = ['/admin/', '/backup/', '/config/', '/.git/']
            for dir_path in dirs_to_check:
                test_url = url.rstrip('/') + dir_path
                try:
                    response = self.session.get(test_url, timeout=5)
                    if response.status_code == 200 and ('index of' in response.text.lower() or 'directory listing' in response.text.lower()):
                        vulnerabilities.append(f"DIRECTORY LISTING ENABLED: {test_url}")
                except:
                    pass

        except Exception as e:
            vulnerabilities.append(f"Vulnerability check error: {str(e)}")

        return vulnerabilities

    def check_common_ports(self, domain):
        """
        Check common vulnerable ports
        """
        common_ports = [21, 22, 23, 25, 53, 80, 110, 143, 443, 993, 995, 3306, 3389]
        open_ports = []

        for port in common_ports:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(1)
                result = sock.connect_ex((domain, port))
                if result == 0:
                    open_ports.append(port)
                sock.close()
            except:
                pass

        return open_ports

    def scan_url_virustotal(self, url):
        """
        Scan URL using VirusTotal API for real threat intelligence
        """
        if not self.virustotal_api_key:
            return {
                'error': 'VirusTotal API key not configured',
                'severity': 'UNKNOWN',
                'threat_score': 0,
                'detections': []
            }

        try:
            # Get URL ID for VirusTotal
            url_id = hashlib.sha256(url.encode()).hexdigest()

            # Check if URL has been scanned before
            headers = {
                'accept': 'application/json',
                'x-apikey': self.virustotal_api_key
            }

            # First, submit URL for analysis if not already scanned
            submit_url = f'https://www.virustotal.com/api/v3/urls'
            submit_data = {'url': url}

            submit_response = self.session.post(submit_url, headers=headers, data=submit_data)
            if submit_response.status_code == 200:
                submit_data = submit_response.json()
                analysis_id = submit_data['data']['id']

                # Wait a moment for analysis
                time.sleep(2)

                # Get analysis results
                analysis_url = f'https://www.virustotal.com/api/v3/analyses/{analysis_id}'
                analysis_response = self.session.get(analysis_url, headers=headers)

                if analysis_response.status_code == 200:
                    analysis_data = analysis_response.json()
                    stats = analysis_data['data']['attributes']['stats']

                    # Calculate threat score (malicious detections / total engines)
                    total_engines = sum(stats.values())
                    malicious_count = stats.get('malicious', 0) + stats.get('suspicious', 0)

                    threat_score = (malicious_count / total_engines * 100) if total_engines > 0 else 0

                    # Determine severity
                    if threat_score >= 50:
                        severity = 'CRITICAL'
                    elif threat_score >= 20:
                        severity = 'HIGH'
                    elif threat_score >= 5:
                        severity = 'MEDIUM'
                    else:
                        severity = 'LOW'

                    detections = []
                    if malicious_count > 0:
                        detections.append(f"{malicious_count} security vendors flagged this URL as malicious")

                    return {
                        'severity': severity,
                        'threat_score': round(threat_score, 2),
                        'detections': detections,
                        'stats': stats,
                        'total_engines': total_engines
                    }
                else:
                    return {
                        'error': f'Failed to get analysis results: {analysis_response.status_code}',
                        'severity': 'UNKNOWN',
                        'threat_score': 0,
                        'detections': []
                    }
            else:
                return {
                    'error': f'Failed to submit URL for analysis: {submit_response.status_code}',
                    'severity': 'UNKNOWN',
                    'threat_score': 0,
                    'detections': []
                }

        except Exception as e:
            return {
                'error': f'VirusTotal API error: {str(e)}',
                'severity': 'UNKNOWN',
                'threat_score': 0,
                'detections': []
            }
