import requests
import ssl
import socket
from urllib.parse import urlparse
import re
import nmap

class VulnerabilityScanner:
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'SECURE-CITY-IQ-Scanner/1.0'
        })

    def scan_url(self, url):
        """
        Perform comprehensive vulnerability scan on a URL
        """
        results = {
            'url': url,
            'vulnerabilities': [],
            'security_headers': {},
            'ssl_info': {},
            'open_ports': [],
            'severity': 'LOW'
        }

        try:
            # Parse URL
            parsed = urlparse(url)
            if not parsed.scheme:
                url = 'https://' + url
                parsed = urlparse(url)

            domain = parsed.netloc
            port = parsed.port or (443 if parsed.scheme == 'https' else 80)

            # Check SSL if HTTPS
            if parsed.scheme == 'https':
                ssl_info = self.check_ssl_certificate(domain, port)
                results['ssl_info'] = ssl_info
                if ssl_info.get('issues'):
                    results['vulnerabilities'].extend(ssl_info['issues'])
                    results['severity'] = 'HIGH'

            # Check security headers
            headers_info = self.check_security_headers(url)
            results['security_headers'] = headers_info
            if headers_info.get('missing_critical'):
                results['vulnerabilities'].extend(headers_info['missing_critical'])
                if results['severity'] == 'LOW':
                    results['severity'] = 'MEDIUM'

            # Check for common vulnerabilities
            vuln_checks = self.perform_vulnerability_checks(url)
            results['vulnerabilities'].extend(vuln_checks)
            if any('CRITICAL' in str(v) or 'HIGH' in str(v) for v in vuln_checks):
                results['severity'] = 'HIGH'

            # Check open ports (basic check)
            ports_info = self.check_common_ports(domain)
            results['open_ports'] = ports_info

        except Exception as e:
            results['vulnerabilities'].append(f"Scan error: {str(e)}")
            results['severity'] = 'UNKNOWN'

        return results

    def check_ssl_certificate(self, domain, port=443):
        """
        Check SSL certificate validity and issues
        """
        info = {'valid': False, 'issuer': '', 'expiry': '', 'issues': []}

        try:
            context = ssl.create_default_context()
            with socket.create_connection((domain, port), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=domain) as ssock:
                    cert = ssock.getpeercert()
                    info['valid'] = True
                    info['issuer'] = dict(cert.get('issuer', []))
                    info['expiry'] = cert.get('notAfter', '')

                    # Check for common SSL issues
                    if 'subjectAltName' not in cert:
                        info['issues'].append("Missing Subject Alternative Name (SAN)")

        except ssl.SSLError as e:
            info['issues'].append(f"SSL Error: {str(e)}")
        except Exception as e:
            info['issues'].append(f"SSL Check Failed: {str(e)}")

        return info

    def check_security_headers(self, url):
        """
        Check for important security headers
        """
        headers = {}
        missing_critical = []

        try:
            response = self.session.get(url, timeout=10, allow_redirects=True)
            response_headers = response.headers

            # Critical security headers
            critical_headers = {
                'X-Frame-Options': 'Prevents clickjacking',
                'X-Content-Type-Options': 'Prevents MIME sniffing',
                'X-XSS-Protection': 'Basic XSS protection',
                'Strict-Transport-Security': 'Enforces HTTPS',
                'Content-Security-Policy': 'Prevents XSS and injection attacks'
            }

            for header, description in critical_headers.items():
                if header in response_headers:
                    headers[header] = response_headers[header]
                else:
                    missing_critical.append(f"Missing {header}: {description}")

            # Check for server info disclosure
            if 'Server' in response_headers:
                headers['Server'] = response_headers['Server']
                if 'apache' in response_headers['Server'].lower() or 'nginx' in response_headers['Server'].lower():
                    missing_critical.append("Server version disclosed - consider hiding server info")

        except Exception as e:
            missing_critical.append(f"Header check failed: {str(e)}")

        return {'headers': headers, 'missing_critical': missing_critical}

    def perform_vulnerability_checks(self, url):
        """
        Perform basic vulnerability checks
        """
        vulnerabilities = []

        try:
            # Test for basic SQL injection
            sql_payloads = ["'", "''", "' OR '1'='1", "' OR 1=1 --"]
            for payload in sql_payloads:
                test_url = url + payload
                try:
                    response = self.session.get(test_url, timeout=5)
                    if 'sql' in response.text.lower() or 'mysql' in response.text.lower() or 'syntax' in response.text.lower():
                        vulnerabilities.append(f"POTENTIAL SQL INJECTION: {test_url}")
                        break
                except:
                    pass

            # Test for XSS
            xss_payloads = ['<script>alert("XSS")</script>', '<img src=x onerror=alert("XSS")>']
            for payload in xss_payloads:
                test_url = url + '?test=' + payload
                try:
                    response = self.session.get(test_url, timeout=5)
                    if payload in response.text:
                        vulnerabilities.append(f"POTENTIAL XSS: {test_url}")
                        break
                except:
                    pass

            # Check for directory listing
            dirs_to_check = ['/admin/', '/backup/', '/config/', '/.git/']
            for dir_path in dirs_to_check:
                test_url = url.rstrip('/') + dir_path
                try:
                    response = self.session.get(test_url, timeout=5)
                    if response.status_code == 200 and ('index of' in response.text.lower() or 'directory listing' in response.text.lower()):
                        vulnerabilities.append(f"DIRECTORY LISTING ENABLED: {test_url}")
                except:
                    pass

        except Exception as e:
            vulnerabilities.append(f"Vulnerability check error: {str(e)}")

        return vulnerabilities

    def check_common_ports(self, domain):
        """
        Check common vulnerable ports
        """
        common_ports = [21, 22, 23, 25, 53, 80, 110, 143, 443, 993, 995, 3306, 3389]
        open_ports = []

        for port in common_ports:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(1)
                result = sock.connect_ex((domain, port))
                if result == 0:
                    open_ports.append(port)
                sock.close()
            except:
                pass

        return open_ports
